#!/usr/bin/env clojure

(require '[clojure.data.csv :as csv])
(require '[clojure.edn :as edn])
(require '[clojure.java.io :as io])
(require '[clojure.set])
(require '[clojure.string :as string])
(require '[clojure.tools.cli :as cli])
(require '[clojure.walk :as walk])
(require '[cheshire.core :as json])

(def cli-options
  [[nil "--model PATH" "model JSON file"
    :id :model
    :parse-fn io/as-file
    :validate [(memfn exists) "File must exist."]]
   [nil "--data PATH" "data CSV file"
    :id :data
    :parse-fn io/as-file
    :validate [(memfn exists) "File must exist."]]
   [nil "--column COLUMN" "column name"
    :id :column]
   [nil "--rename RENAME" "rename mapping"
    :id :rename
    :parse-fn edn/read-string]
   ["-h" "--help" "help"
    :id :help]])

(defn usage [options-summary]
  (->> ["Usage: bin/rename [options]"
        ""
        "Options:"
        options-summary]
       (string/join \newline)))

(defn error-msg [errors]
  (str "The following errors occurred while parsing your command:\n\n"
       (string/join \newline errors)))

(def required-options #{:data :model :column :rename})

(defn validate-args
  [args]
  (let [{:keys [options arguments errors summary]} (cli/parse-opts args cli-options)]
    (cond (:help options)
          {:ok? true :exit-message (usage summary)}

          errors
          {:ok? false :exit-message (error-msg errors)}

          (not (clojure.set/subset? required-options (set (keys options))))
          {:ok? false :exit-message (str "Missing required arguments: "
                                         (->> (clojure.set/difference required-options (keys options))
                                              (map #(str "--" (name %)))
                                              (clojure.string/join ", "))
                                         "\n\n"
                                         (usage summary))}

          :else
          {:ok? true :options options})))

(defn exit [status msg]
  (println msg)
  (System/exit status))

(defn update-model-json!
  [{:keys [model rename]}]
  (as-> (slurp model) $
    (json/parse-string $)
    (walk/prewalk-replace rename $)
    (json/generate-string $ {:pretty true})
    (spit model $)))

(defn- csv-data->maps [csv-data]
  (map zipmap
       (->> (first csv-data) ; headers
            #_(map keyword)
            repeat)
       (rest csv-data)))

(defn update-data-csv!
  [{:keys [data column rename]}]
  (let [csv-data (with-open [reader (io/reader data)]
                   (doall (csv/read-csv reader)))
        updated-data (->> (csv-data->maps csv-data)
                          (mapv (fn [row]
                                  (update row column #(get rename % %))))
                          (mapv (fn [row-map]
                                  (mapv (fn [column]
                                          (get row-map column))
                                        (first csv-data)))) ; headers
                          (into [(first csv-data)]))]
    (with-open [writer (io/writer data)]
      (csv/write-csv writer updated-data))))

(defn rename
  [options]
  (update-model-json! options)
  (update-data-csv! options))

(defn -main [& args]
  (let [{:keys [options exit-message ok?]} (validate-args args)]
    (if exit-message
      (exit (if ok? 0 1) exit-message)
      (rename options))))

(apply -main *command-line-args*)
