(ns inferenceql.multimixture.crosscat
  (:require [inferenceql.multimixture.primitives :as prim]
            [inferenceql.multimixture.utils      :as mmix-utils]))

;; "LogPDF score" is used for data that hasn't been incorporated into
;; the CrossCat model, and so has no latent assignment. I'm uncertain
;; about the usefulness of these particular functions, so I'm keeping
;; them and their tests around for now.
(defn category-logpdf-score
  "Calculates the log probability of data under a given category.
  Assumes `x` contains only columns in that category."
  [x types category]
  (let [parameters (:parameters category)]
    (apply + (mapv (fn [[col value]]
               (let [col-type   (get types col)
                     col-params (get parameters col)]
                 (prim/logpdf value col-type col-params))) x))))

(defn view-logpdf-score
  "Calculates the log probability of data under a given view.
  Assumes `x` contains only columns in that view."
  [x types latents view]
  (let [crp-counts      (:counts latents)
        n               (apply + crp-counts)
        crp-counts-norm (map #(Math/log (/ % n)) crp-counts)
        categories      (:categories view)]
    (->> categories
         (map #(category-logpdf-score x types %))
         (map (comp #(apply + %) vector) crp-counts-norm)
         mmix-utils/logsumexp)))

(defn logpdf-score
  "Calculates the log probability of data under a given CrossCat model."
  [x model latents]
  (let [types            (:types model)
        view-assignments (get-in latents [:global :z])
        views            (:views model)]
    (->> views
         (map-indexed (fn [view-idx view]
                        (let [x-view (into {} (filter #(= view-idx
                                                          (get view-assignments (first %)))
                                                      x))]
                          (view-logpdf-score x-view types (get-in latents [:local view-idx]) view))))
         (reduce +))))

;; "Log likelihood" is used to evaluate the current latent assignments
;; of the data contained in the model.
(defn log-likelihood-view
  "Given a datum, its category assignment, and the corresponding view,
  returns the log-likelihood that the datum was generated by that view."
  [x row-id types latents view]
  (let [assignment      (get-in latents [:y row-id])
        category        (get-in view    [:categories assignment])]
    (category-logpdf-score x types category)))

(defn log-likelihood-views
  "Given a datum, its category assignments across views, and the corresponding model,
  returns the log-likelihood that the datum was generated by that model."
  [x row-id model latents]
  (let [types            (:types model)
        views            (:views model)
        view-assignments (get-in latents [:global :z])]
    (->> views
         (map-indexed (fn [view-idx view]
                        (let [x-view (into {} (filter #(= view-idx
                                                          (get view-assignments (first %)))
                                                      x))]
                          (log-likelihood-view
                            x-view
                            row-id
                            types
                            (get-in latents [:local view-idx])
                            view))))
         (reduce +))))

(defn log-likelihood
  "Given a dataset, returns the likelihood of the dataset under the model,
  as well as the latents structure, which is data-specific."
  [data model latents]
  (let [data-formatted   (->> data
                              (map (fn [[col-name values]]
                                     (map (fn [value]
                                            {col-name value})
                                          values)))
                              (mmix-utils/transpose)
                              (map #(apply merge %)))
        ]
      (->> data-formatted
           (map-indexed (fn [row-id x]
                          (log-likelihood-views x row-id model latents)))
           (reduce +))))

(defn crp-weights
  "Given alphas and counts of customers per table, returns weights
  representing the corresponding CRP."
  [alpha counts]
  (let [n (apply + counts)]
    (->> (concat counts [alpha])
         (map (fn [cnt] (Math/log (/ cnt (+ n alpha))))))))

(defn simulate-category
  "Given a category, statistical types, and constraints, simulates unconstrained values."
  [category types targets constraints]
  (let [parameters-to-sample (->> (:parameters category)
                                  (filter (fn [[k params]]
                                            (and (not (contains? constraints k))
                                                 (contains? targets k))))
                                  (into {}))]
    (->> parameters-to-sample
         (map (fn [[col-name col-params]]
                (let [col-type (get types col-name)]
                  {col-name (prim/simulate col-type col-params)})))
         (into {}))))
         ; (merge constraints)))) need to choose whether to return with/out constraints

(defn hyperprior-simulate
  "Given a hyperprior, simulates a new hyperparameter."
  [hyperprior]
  (let [[primitive parameters] (first (vec hyperprior))]
    (prim/simulate primitive parameters)))

(defn categorical-param-names
  [view col-name]
  (keys (get-in view [:categories 0 :parameters col-name :p])))

(defn generate-category
  "Given a view and statistical types, simulates a category specification
  from that view."
  [m view types]
  (repeatedly m #(let [hypers     (:hypers view)
                       view-types (select-keys types (keys hypers)) ]
                   (->> hypers
                        (map (fn [[col-name hyperpriors]]
                               {col-name (into {} (map (fn [[hyper-name hyper-dist]]
                                                         (if (= :categorical (get view-types col-name))
                                                           {hyper-name (zipmap (categorical-param-names view col-name)
                                                                               (hyperprior-simulate hyper-dist))}
                                                           {hyper-name (hyperprior-simulate hyper-dist)}))
                                                       hyperpriors))}))
                        (into {})
                        (assoc {} :parameters)))))

(defn view-category-weights
  "Returns weights of all categories. When `constraints` is non-empty, the weights
  are reweighted by likelihood of categories generating the constrained values."
  [categories latents types constraints]
  (let [alpha       (:alpha latents)
        counts      (:counts latents)
        crp-weights (crp-weights alpha counts)]
    (if (empty? constraints)
      crp-weights
      (let [adjusted-weights (map + crp-weights (map (fn [category]
                                                       (category-logpdf-score
                                                         constraints
                                                         types
                                                         category))
                                                     categories))
            Z (mmix-utils/logsumexp adjusted-weights)]
        (map (fn [weight] (- weight Z)) adjusted-weights)))))

(defn sample-category
  "Given weights and a list of categories of equal length, samples a category."
  [weights categories]
  (let [probs {:p (zipmap (range (count categories)) weights)}]
    (nth categories (prim/simulate :log-categorical probs))))

(defn simulate-view
  "Given a view and constraints, simulates unconstrained values from that view."
  [view latents types targets constraints & {:keys [:m] :or {m 1}}]
  (let [aux-categories (generate-category m view types)
        categories     (concat (:categories view) aux-categories)
        weights        (view-category-weights categories latents types constraints)
        category       (sample-category weights categories)]
    (simulate-category category types targets constraints)))

(defn simulate
  "Given a model, latents, and possible constraints, simulates
  unconstrained values from the model."
 [model latents & {:keys [:targets :constraints] :or {constraints {}}}]
   (let [views (:views model)
         types (:types model)]
     (->> views
          (map-indexed (fn [view-idx view]
                         (let [view-latents     (get-in latents [:local view-idx])]
                           (simulate-view view view-latents types targets constraints))))
          (into {}))))



;; OLD STUFF TO BE DELETED/REPURPOSED

; (defn category-assignment-simulate
;   "Simulates a category assignment given a view's concentration parameter
;   and category-row counts."
;   [alpha counts]
;   (let [crp-probs (crp-alpha-counts alpha counts)]
;     (prim/categorical-simulate crp-probs)))

; (defn category-simulate
;   "Given a category and statistical types, simulates a value from that category."
;   [types category]
;   (let [parameters (:parameters category)]
;     (into {}
;           (pmap (fn [[col-name col-params]]
;                   (let [col-type (col-name types)]
;                     {col-name (prim/simulate col-type col-params)}))
;                 parameters))))

; (defn generate-category
;   "Given a view and statistical types, simulates a category specification
;   from that view."
;   ([view types]
;    (let [hypers     (:hypers view)
;          view-types (select-keys types (keys hypers)) ]
;      (->> hypers
;           (map (fn [[col-name hyperpriors]]
;                   {col-name (into {} (map (fn [[hyper-name hyper-dist]]
;                                             (if (= :categorical (get view-types col-name))
;                                              {hyper-name (zipmap (categorical-param-names view col-name)
;                                                                  (hyperprior-simulate hyper-dist))}
;                                              {hyper-name (hyperprior-simulate hyper-dist)}))
;                                          hyperpriors))}))
;           (into {})
;           (assoc {} :parameters))))
;   ([n view types]
;    (repeatedly n #(generate-category view types))))

; (defn view-simulate
;   "Given latents and a view, simulates a sample from that view."
;   [types latents view]
;   (let [alpha         (:alpha latents)
;         counts        (:counts latents)
;         n-categories  (count counts)
;         y             (category-assignment-simulate alpha counts)]
;     (if (= y n-categories)
;       (category-simulate types (generate-category  view types))
;       (category-simulate types (get-in view [:categories y])))))

; (defn simulate
;   "Given a CrossCat model and latent variables, simulates a sample from
;   that model."
;   [model latents]
;   (let [column-types (:types model)
;         views        (:views model)
;         view-latents (map vector views (:local latents))]
;     (into {} (pmap (fn [[view latent]] (view-simulate column-types latent view)) view-latents))))
